{
  "id": "animeunity",
  "name": "AnimeUnity",
  "description": "AnimeUnity is an online streaming provider for subbed/dubbed animes in Italian.",
  "manifestURI": "",
  "version": "1.0.0",
  "author": "YourName",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\"/>\n\nclass Provider {\n  api = \"https://www.animeunity.so\";\n\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Server 1\", \"Server 2\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query[\"query\"]);\n    console.log(\"Normalized Query: \" + normalizedQuery);\n\n    const url = `${this.api}/search?keyword=${encodeURIComponent(normalizedQuery)}`;\n\n    try {\n      const data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const animes: SearchResult[] = [];\n\n      $(\"div.card-body\").each((_, elem) => {\n        const id = elem.find(\"a\").attr(\"href\")?.slice(1) ?? \"\";\n        const title = elem.find(\"a\").text().trim();\n        const subOrDub: SubOrDub = this.isSubOrDubOrBoth(elem);\n        const url = `${this.api}/${id}`;\n\n        animes.push({ id, url, title, subOrDub });\n      });\n\n      return animes;\n    } catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    const url = `${this.api}/anime/${id}`;\n\n    try {\n      let data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const episodes: EpisodeDetails[] = [];\n\n      $('div.episode-list a').each((_, elem) => {\n        const episodeId = elem.attr('href')?.split('/').pop() ?? \"\";\n        const number = parseInt(elem.text().trim(), 10);\n        const title = elem.text().trim();\n\n        episodes.push({ id: episodeId, number, title, url: `${this.api}/episode/${episodeId}` });\n      });\n\n      return episodes;\n    } catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    const episodeUrl = episode.url;\n\n    try {\n      const responseText = await this._makeRequest(episodeUrl);\n      const $ = LoadDoc(responseText);\n      let videoUrl = $('video source').attr('src') || '';\n\n      if (!videoUrl) {\n        throw new Error(\"No video source found.\");\n      }\n\n      const episodeServer: EpisodeServer = {\n        server: \"AnimeUnity Server\",\n        headers: { \"Access-Control-Allow-Origin\": \"*\" },\n        videoSources: [{\n          quality: \"1080p\",\n          subtitles: [],\n          type: \"mp4\",\n          url: videoUrl\n        }]\n      };\n\n      return episodeServer;\n    } catch (e: any) {\n      throw new Error(e);\n    }\n  }\n\n  normalizeQuery(query: string): string {\n    return query.replace(/\s+/g, \" \").trim();\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: { \"User-Agent\": \"Mozilla/5.0\" }\n    });\n    if (!response.ok) {\n      throw new Error(`Failed to fetch: ${response.statusText}`);\n    }\n    return await response.text();\n  }\n\n  isSubOrDubOrBoth(elem: DocSelection): SubOrDub {\n    const sub = elem.find(\"span.sub\").text();\n    const dub = elem.find(\"span.dub\").text();\n\n    if (sub && dub) return \"both\";\n    if (sub) return \"sub\";\n    return \"dub\";\n  }\n}\n"}

