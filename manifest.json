{
  "id": "animesaturn",
  "name": "AnimeSaturn",
  "description": "AnimeSaturn Ã¨ un provider di streaming online per anime sottotitolati e doppiati in italiano",
  "manifestURI": "https://raw.githubusercontent.com/RubRix22/anisaturn-extention-for-seanime/main/manifest.json",
  "version": "1.0.0",
  "author": "RubRix22",
  "type": "onlinestream-provider",
  "language": "typescript",
  "lang": "it",
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\"/>\n\nclass Provider {\n  api = \"https://animesaturn.to\";\n  getSettings(): Settings {\n    return {\n      episodeServers: [\"Server 1\", \"Server 2\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query: SearchOptions): Promise<SearchResult[]> {\n    let normalizedQuery = this.normalizeQuery(query[\"query\"]);\n    console.log(\"Normalized Query: \" + normalizedQuery);\n\n    const url = `${this.api}/browser?keyword=${encodeURIComponent(normalizedQuery)}`;\n\n    try {\n      const data = await this._makeRequest(url);\n      const $ = LoadDoc(data);\n      const animes: SearchResult[] = [];\n\n      $(\"div.aitem-wrapper>div.aitem\").each((_, elem) => {\n        const id = elem.find(\"a.poster\").attr(\"href\")?.slice(1) ?? \"\";\n        const title = elem.find(\"a.title\").attr(\"title\") ?? \"\";\n        const subOrDub: SubOrDub = this.isSubOrDubOrBoth(elem);\n        const url = `${this.api}/${id.slice(1)}`;\n\n        const anime: SearchResult = {\n          id: `${id}?dub=${query['dub']}`,\n          url: url,\n          title: title,\n          subOrDub: subOrDub,\n        };\n\n        animes.push(anime);\n      });\n\n      return animes;\n    } catch (ex: any) {\n      throw new Error(ex);\n    } \n  }\n\n  async findEpisodes(id: string): Promise<EpisodeDetails[]> {\n    const url = `${this.api}/${id.split('?dub')[0]}`;\n    try {\n      const data = await this._makeRequest(url);\n      const episodes: EpisodeDetails[] = [];\n      const $ = LoadDoc(data);\n\n      $('ul.range>li>a').each((_, elem) => {\n        const title = elem.find('span').text().replace(/\\s/g, ' ');\n        const number = parseInt(elem.attr('num')!, 10);\n        const token = elem.attr('token');\n        const episodeUrl = `${this.api}/ajax/links/list?token=${token}`;\n\n        episodes.push({\n          id: token ?? \"\",\n          number: number,\n          title: title,\n          url: `${episodeUrl}?dub=${id.split('?dub=')[1]}`\n        });\n      });\n\n      return episodes;\n    } catch (ex: any) {\n      throw new Error(ex);\n    }\n  }\n\n  async findEpisodeServer(episode: EpisodeDetails, _server: string): Promise<EpisodeServer> {\n    let server = \"Server 1\";\n    if (_server !== \"default\") server = _server;\n    \n    const episodeUrl = episode.url.replace('\\u0026', '&').split('?dub')[0];\n    try {\n      const responseText = await this._makeRequest(episodeUrl);\n      const cleanedHtml = cleanJsonHtml(responseText);\n      \n      // Regex per trovare i server\n      const serverRegex = /<span class=\\"server\\"[^>]*data-lid=\\"([^\\"]+)\\"[^>]*>${server}<\/span>/;\n      const serverMatch = serverRegex.exec(cleanedHtml);\n\n      if (serverMatch && serverMatch[1]) {\n        const streamUrl = `${this.api}/ajax/links/view?id=${serverMatch[1]}`;\n\n        const episodeServer: EpisodeServer = {\n          server: server,\n          headers: {\n            \"Access-Control-Allow-Origin\": \"*\",\n            'User-Agent': 'Mozilla/5.0'\n          },\n          videoSources: [{\n            quality: '1080p',\n            type: 'm3u8',\n            url: streamUrl\n          }]\n        };\n\n        return episodeServer;\n      }\n      throw new Error(\"Nessuna sorgente trovata\");\n    } catch (e: any) {\n      throw new Error(e);\n    }\n  }\n\n  async _makeRequest(url: string): Promise<string> {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        \"DNT\": \"1\",\n        \"User-Agent\": \"Mozilla/5.0\"\n      },\n    });\n    if (!response.ok) {\n      throw new Error(`Errore di fetch: ${response.statusText}`);\n    }\n    return await response.text();\n  }\n\n  normalizeQuery(query: string): string {\n    return query.replace(/\\s+/g, \" \").trim();\n  }\n\n  isSubOrDubOrBoth(elem: DocSelection): SubOrDub {\n    const sub = elem.find(\"span.sub\").text();\n    const dub = elem.find(\"span.dub\").text();\n\n    if (sub !== \"\" && dub !== \"\") {\n      return \"both\";\n    }\n    return sub !== \"\" ? \"sub\" : \"dub\";\n  }\n}\n"}
